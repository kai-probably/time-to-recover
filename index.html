<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Time to Recover</title>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    /* ==== CSS (layout + colors) ==== */

    :root {
      --bg: #f6f8fb;
      --card: #ffffff;
      --text: #0f1114;
      --muted: #4b5563;
      --border: rgba(15,17,20,0.12);

      --accent: #1d68d8;
      --danger: #d81d3a;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg);
      color: var(--text);
    }

    .wrap {
      max-width: 900px;
      margin: 40px auto;
      padding: 0 16px;
    }

    .card {
      background: var(--card);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }

    .chartWrap {
      height: 320px;
    }

    .miniHint {
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
    }
  </style>
</head>

<body>
  <main class="wrap">

    <section class="card">
      <h1>Time to Recover</h1>
      <p class="miniHint">
        Estimates short-term recovery. No performance prediction.
      </p>

      <div class="chartWrap">
        <canvas id="recoveryChart"></canvas>
      </div>
    </section>

  </main>

  <script>
    /* ==== MODEL ==== */
    function makeModel({ intensity, durationMin, hoursSince }, { readyFraction }) {
      const load = intensity * durationMin;
      const tau = 14 + intensity * 4;

      function fatigueAt(h) {
        return load * Math.exp(-h / tau);
      }

      const fatigueNow = fatigueAt(hoursSince);
      const recovery = load > 0 ? 1 - fatigueNow / load : 1;

      return {
        recovery,
        readyRecovery: 1 - readyFraction,
        fatigueAt
      };
    }

    /* ==== ZONE PLUGIN ==== */
    const zonesPlugin = {
      id: "zones",
      beforeDraw(chart) {
        const { ctx, chartArea, scales, options } = chart;
        if (!chartArea) return;

        const opts = options.plugins.zones;
        const y = scales.y;

        const readyY = y.getPixelForValue(opts.ready);
        const fullY = y.getPixelForValue(opts.full);

        // Fatigue-dominant
        ctx.fillStyle = opts.danger;
        ctx.fillRect(
          chartArea.left,
          readyY,
          chartArea.right - chartArea.left,
          chartArea.bottom - readyY
        );

        // Fully recovered
        ctx.fillStyle = opts.positive;
        ctx.fillRect(
          chartArea.left,
          chartArea.top,
          chartArea.right - chartArea.left,
          fullY - chartArea.top
        );
      }
    };

    Chart.register(zonesPlugin);

    /* ==== CHART ==== */
    const ctx = document.getElementById("recoveryChart");
    const chart = new Chart(ctx, {
      type: "line",
      data: {
        labels: [],
        datasets: [{
          label: "Recovery",
          data: [],
          borderColor: getComputedStyle(document.documentElement).getPropertyValue("--accent"),
          tension: 0.3,
          pointRadius: 0
        }]
      },
      options: {
        animation: false,
        scales: {
          y: { min: 0, max: 1 }
        },
        plugins: {
          legend: { display: false },
          zones: {
            ready: 0.75,
            full: 0.9,
            danger: "rgba(216,29,58,0.12)",
            positive: "rgba(29,104,216,0.06)"
          }
        }
      }
    });

    /* ==== UPDATE ==== */
    const model = makeModel(
      { intensity: 3, durationMin: 60, hoursSince: 12 },
      { readyFraction: 0.25 }
    );

    const labels = [];
    const values = [];

    for (let h = 0; h <= 72; h++) {
      labels.push(h);
      values.push(model.fatigueAt(h) / (model.fatigueAt(0)) ? 1 - model.fatigueAt(h) / model.fatigueAt(0) : 1);
    }

    chart.data.labels = labels;
    chart.data.datasets[0].data = values;
    chart.update();
  </script>
</body>
</html>